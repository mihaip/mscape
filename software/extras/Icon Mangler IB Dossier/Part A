Statement of the Problem	The problem is quite simple. Mac OS 8.5 introduced a new icon format. In previous versions, a collection of resources was used to represent the icon at various depths (1 bit, 4 bit (16 colors) and 8 bit (256 colors)) along with a simple 1 bit mask (the mask specifies which pixels of the icon should be drawn, and which should be left as they are. It can be thought of as a silouette of the icon, refer to screenshot A-1 for a graphical explanation of how the mask workds). For each depth there are two available sizes, large (32 by 32 pixels) and small (16 by 16 pixels). The new format takes all of these parts, adds an additional icon depth (32 bits, really 24 bits since the 8 alpha channel bits are unused, giving a maximum of 16.7 million colors), an additional mask depth (8 bit, with 256 levels of transparency, refer to screenshot A-1 for a graphical example of how this would work) and an additional size (huge, 48 x 48 pixels). Instead of having each one of the depth/size combinations be stored in a separate resource (as was the case with previous systems), a new storage format was also introduced, the 'icns' resource. Within this resource there is a list (of a dynamic size) of all the size/depth icons and their pixel data.	As its probably become obvious by now, Apple (which makes Mac OS 8.5) has not provided a direct way in which these icons can be edited. Of course one could go in and edit the 'icns' resource by hand (by typing in hex) but that is not an appropriate way to edit graphical data. Instead an editor must be provided, and that is my goal. Fortunately, graphical editors (and even icon editors for the old format) have been done before, and thus the existence of a precedent will make my job much easier. There are certain standards which must be followed (ie. certain tools like a pencil, a line and a paint bucked tool, or a way to select items and move them around must be provided) and so the basic design aspects of the editor are already taken care of. The things which I must do are to design an interface for the icon specifc aspects of the editor (since we must be able to switch back and forth between the various sizes/depths) as well as the actual code and implementation of such an editor (since neither have I ever done a graphical editor before, or seen the way in which it is structured).Method of SolutionStructuring of the Program	I have decided that an object oriented approach would make the most sense. This is because it is possible to have more than one icon opened to be edited at the same time, and in this case it would be appropriate to have several editors opened. In my case I can treat each editor as an instance of a class, and keep track of all of them by using a mechanism such as a linked list.	Another design decision is that there must be a very clear separation between the editor class and the application itself. This will not only help me during the design, but it will also aid me in the future if I want to incorporate the editor into another (bigger) application, since it should be rather easy to make the transfer if the application and the editor are not tightly interwoven. To this end the application must receive the user's events, and pass them on to the editor class (if necessary of course). If the class wants to communicate with the application, a status variable should be used, in which different bits specify different messages. In this way all of the implementation details (such as how to handle drawing) will be private to the class, since the application should not have to worry about that (this is called encapsulation).Datatypes	Therefore the editor class (datatype name: icnsEditorClass) will be the main class of the program. From an earlier project I have an icnsClass which handled the loading and drawing of icons, and thus I can derive the editor class from it. To keep track of all the opened editors, a linked list will be used. Another datatype which I intend to use is a class for saving the drawing state (this will be used to implement the Undo/Redo functions). The idea here is to save the current state of the drawing as the user performs operations, and to store the saved states in a linked lists. Then undoing should simply be a matter of going back through the list and restoring (while redoing will involve going forward). Other datatypes which will be used are a structure for keeping track of all the controls within each editor window. Also there is some global data that is used in all open editors (a "canvas" PixMap where temporary drawing can be done, certain shared resources) so these will be a subclass of the editor class, and it will be declared as static (meaning that there is only one instance for all the copies of the editor).The Interface	The other main design decision, the interface is took a bit longer to solve. The initial part wasy easy. Most editors have a tool palette, which provides a real world equivalent to how a painter would work (see screenshot A-2 for a typical palette, in this case the one used by Adobe Photoshop, a very popular program among the higher end artists). The harder part was determining how to handle the various depths and sizes. Most icon programs until now displayed all of them at the same time (see screenshot A-3 of how ResEdit, an older Apple-built tool to edit icons, among other resources) and allowed the user to click on them in order to switch among them. However the old icon format needed only 8 slots for this (2 sizes x 1 bit mask, 1 bit icon, 4 bit icon, 8 bit icon). In my case I have 18 slots (3 sizes x 1 bit mask, 8 bit mask, 1 bit icon, 4 bit icon, 8 bit icon, 32 bit icon). To display all of them at once would take up more than half the space of an editors window. Using a prototyping tool (in this case the interface editor of REALBasic) I have come up with an alternate solution. The solution is based on the assumption that the user would only want to edit one depth at a time (for each size) and them move on. Then the switching between depths could be accomplished by the use of a pop-up menu. Then we would only need to display 3 slots (one for each size) at the same time. However the mask is an integral part of the icon, so we can safely assume that user would want to edit it simoulatenously with the icon. Therefore we can add a further 3 slots for the 3 sizes of the mask. Since there are two depths for the mask (1 bit and 8 bit) we would a popup menu for choosing among depths here too. This bring the total 6 slots, which is much better than the alternative of having 18. A preview area is also needed, where we display the combination of the currently selected icon and mask against an appropriate background (perhaps the same color as the desktop). Screenshot A-4 shows the prototype.	Another interface decisions which had to be made was how to handle the opening of files with more than one icon. This is more commom than it sounds. Applications often store within themselves both their own icon, as well as the icons that documents made by them will use. Also, icon collections can be stored in a single file instead of individually. I decided that an Icon Browser should come up if the user selected a file which contained more than one icon resource. I again used REALBasic try to come up with a prototype. In this case I had two possible interfaces, with different styles of displaying the icon list (see Screenshot A-5). After collecting some feedback from possible users, I decided upon the second prototype, since the large icon display in the list was redundant.Other Decisions	A guiding principle for this application is to store as little as possible hard coded data within the source code (eg error strings, menus, controls). Rather they will be loaded from resources. Resources are an unique Mac concept; each file is divided into a data fork (usually this is where the compiled code goes into) and a resource fork (which is structured, and be edited independently of the data fork with a resource editor). The main advantage of using resources is that it is very easy to make changes to the application. For example if I want to make a localized version in a different language, it is simply a matter of sending the resource file to the person doing the translation, without having to worry that will be see the source code.	Hardware is not a big issue for this problem. Obviously a mouse would be the best input method, since we are dealing with graphical data. Fortunately every Macintosh has come with a mouse, so this is not an issue. Of course keyboard shortcuts will be provided for common actions, and there are certain standards (both specified by Apple, and common in other applications) with which I will comply. For the software requirements, Mac OS 8.5 will be sufficient, since it includes all the techonologies that the program requires (like the Appearance Manager, which I'll be using for the drawing of controls).	The way in which the program deals with input/output is very much like any other Mac program. At the heart of it we have the event loop. Here we wait until an event has happened. Then based on the event type we take the appropriate action. The functions which handle events attempt to deal with them, and if they involve an editor class then the event in question is passed on to the class.